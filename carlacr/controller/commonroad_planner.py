import copy
from typing import Optional, Union
import logging
import carla
import numpy as np

from commonroad.scenario.state import TraceState
from commonroad.scenario.scenario import Scenario
from commonroad.planning.planning_problem import PlanningProblem
from commonroad.scenario.state import State
from commonroad.planning.goal import GoalRegion
from crpred.predictor_interface import PredictorInterface
from commonroad_route_planner.route_planner import RoutePlanner

from carlacr.controller.controller import CarlaController
from carlacr.helper.config import VehicleControlType, ControlParams
from carlacr.controller.controller import TransformControl
from carlacr.controller.vehicle_controller import PIDController, AckermannController, \
    VehicleTMPathFollowingControl, VehicleBehaviorAgentPathFollowingControl
from carlacr.helper.planner import TrajectoryPlannerInterface
from carlacr.helper.utils import create_cr_vehicle_from_actor, create_cr_initial_state_from_actor

logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)


def create_scenario_from_world(world: carla.World, sc: Scenario) -> Scenario:
    """
    Creates scenario without prediction from CARLA world.

    :param world: CARLA world.
    :param sc: Base scenario containing road network and static obstacles.
    :return: CommonRoad scenario.
    """
    for actor in world.get_actors():
        sc.add_objects(create_cr_vehicle_from_actor(actor, sc.generate_object_id()))
    return sc


def get_planning_problem_from_world(world: carla.World, gpp: PlanningProblem) -> PlanningProblem:
    """
    Creates planning problem from CARLA world.

    :param world: CARLA world.
    :param gpp: Global planning problem.
    :return: CommonRoad planning problem.
    """
    return PlanningProblem(gpp.planning_problem_id, create_cr_initial_state_from_actor(world.get_actor(0), 0),
                           GoalRegion([State(60)]))


def compute_global_route(sc: Scenario, pp: PlanningProblem) -> np.ndarray:
    """
    Computes global route from a given initial state to goal region.
    This route should not be used for planning. It is mainly used for extracting the sub-planning problems.

    :param sc: CommonRoad scenario.
    :param pp: Planning problem.
    :return: Route.
    """
    return RoutePlanner(sc, pp).plan_routes().retrieve_first_route().reference_path


class CommonRoadPlannerController(CarlaController):
    """Controller which uses trajectory generated by CommonRoad planner as input."""

    def __init__(self, actor: carla.Actor, planner: TrajectoryPlannerInterface, predictor: PredictorInterface,
                 pp: PlanningProblem, sc: Scenario, control_type: VehicleControlType, dt: float,
                 control_config: ControlParams):
        """
        Initialization of CommonRoad planner controller.

        :param actor: CARLA actor.
        :param planner: CommonRoad planner.
        :param predictor: CommonRoad predictor.
        :param pp: CommonRoad planning problem.
        :param sc: Base scenario containing road network and static obstacles.
        :param control_type: CARLA control type used for CommonRoad planner.
        :param dt: Time step size.
        :param control_config: CARLA controller params.
        """
        super().__init__(actor)
        self._planner = planner
        self._predictor = predictor
        self._base_sc = copy.deepcopy(sc)
        self._global_pp = pp
        self._global_route = compute_global_route(self._base_sc, self._global_pp)
        self._current_trajectory = None
        self._controller = self._create_controller(control_type, dt, control_config)

    def _create_controller(self, control_type: VehicleControlType, dt: float, control_config: ControlParams) \
            -> Union[TransformControl, PIDController, AckermannController, VehicleBehaviorAgentPathFollowingControl,
                     VehicleTMPathFollowingControl]:
        """
        Creates CARLA controller object.

        :param control_type: CARLA control type used for CommonRoad planner.
        :param dt: Time step size.
        :param control_config: CARLA controller params.
        :return: CARLA controller.
        """
        if control_type is VehicleControlType.TRANSFORM:
            return TransformControl(self._actor)
        if control_type is VehicleControlType.PID:
            return PIDController(actor=self._actor, config=control_config, dt=dt)
        if control_type is VehicleControlType.ACKERMANN:
            return AckermannController(self._actor, config=control_config)
        if control_type is VehicleControlType.PATH_TM:
            return VehicleTMPathFollowingControl(self._actor)
        if control_type is VehicleControlType.PATH_AGENT:
            return VehicleBehaviorAgentPathFollowingControl(self._actor)
        logger.error("CommonRoadPlannerController::_create_controller: Unknown controller type.")
        return TransformControl(self._actor)

    def _reset_base_scenario(self):
        """Removes all dynamic obstacles from base scenario."""
        for obs in self._base_sc.dynamic_obstacles:
            self._base_sc.remove_obstacle(obs)

    def control(self, state: Optional[TraceState] = None):
        """
        Computes and applies CARLA steering wheel control.

        :param state: State which should be reached at next time step.
        """
        self._reset_base_scenario()
        world = self._actor.get_world()
        sc = create_scenario_from_world(world, self._base_sc)
        if self._predictor is not None:
            sc = self._predictor.predict(sc, 0)
        pp = get_planning_problem_from_world(world, self._global_pp)
        self._current_trajectory = self._planner.plan(sc, pp)
        self._controller.control(self._current_trajectory.state_list[0])
